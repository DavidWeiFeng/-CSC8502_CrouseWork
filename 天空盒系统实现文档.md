# 天空盒系统实现文档

## 📋 文档信息
- **创建日期**：2025年10月28日
- **功能优先级**：⭐⭐⭐ 第1优先级
- **预计实现时间**：1-2天
- **依赖系统**：纹理系统、着色器系统、相机系统

---

## 🎯 功能概述

### 什么是天空盒（Skybox）？

天空盒是一个**包围整个场景的立方体**，用于模拟远处的天空、云彩、山脉等环境背景。它给玩家一种身处广阔世界中的沉浸感。

### 核心特点
- ✅ 使用**立方体贴图（Cubemap）**技术
- ✅ 由6张纹理组成（上、下、左、右、前、后）
- ✅ 始终渲染在场景的最远处（深度值永远为1.0）
- ✅ 跟随相机旋转，但**不跟随相机位移**（保持无限远的感觉）
- ✅ 是环境映射的基础（反射、折射效果需要它）

### 为什么现在实现？
1. ✅ 视觉效果立竿见影 - 替代单色背景
2. ✅ 技术难度适中 - 比模型加载简单
3. ✅ 是环境映射的前置条件（课程要求）
4. ✅ 为冬夏场景转换奠定基础

---

## 🏗️ 技术原理

### 1. 立方体贴图（Cubemap）

**普通2D纹理 vs 立方体纹理：**

```
普通纹理：使用 (u, v) 坐标访问
立方体纹理：使用 3D 方向向量 (x, y, z) 访问
```

**立方体贴图的6个面：**
```
     +----+
     | +Y |  上（top）
+----+----+----+----+
| -X | +Z | +X | -Z |  左、前、右、后
+----+----+----+----+
     | -Y |  下（bottom）
     +----+

OpenGL立方体贴图面的顺序：
GL_TEXTURE_CUBE_MAP_POSITIVE_X (+X, 右)
GL_TEXTURE_CUBE_MAP_NEGATIVE_X (-X, 左)
GL_TEXTURE_CUBE_MAP_POSITIVE_Y (+Y, 上)
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y (-Y, 下)
GL_TEXTURE_CUBE_MAP_POSITIVE_Z (+Z, 前)
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z (-Z, 后)
```

### 2. 渲染技巧

**问题：如何让天空盒始终在最远处？**

#### 技巧1：移除View矩阵的平移分量
```glsl
// 在顶点着色器中
mat4 viewWithoutTranslation = mat4(mat3(view));
// 只保留旋转，去除平移
```

**原理：**
- 普通物体：`MVP = projection * view * model`
- 天空盒：`MVP = projection * mat4(mat3(view)) * model`
- `mat4(mat3(view))` 将view矩阵转为3x3（去除平移），再转回4x4

#### 技巧2：深度值设为1.0
```glsl
// 顶点着色器输出
gl_Position = position.xyww;  // 注意：使用xyww而不是xyzw
```

**原理：**
- 透视除法后：`depth = z / w`
- 使用 `xyww`：`depth = w / w = 1.0`（最远深度）
- 保证天空盒永远在所有物体后面

#### 技巧3：先渲染其他物体，最后渲染天空盒
```cpp
// 渲染顺序
glDepthFunc(GL_LESS);      // 正常深度测试
渲染地形、树木、岩石...

glDepthFunc(GL_LEQUAL);    // 允许深度值等于1.0通过
渲染天空盒
glDepthFunc(GL_LESS);      // 恢复
```

---

## 📁 代码结构

### 新增文件

```
8502_CrouseWork/
├── Skybox.h                    # 天空盒类头文件
├── Skybox.cpp                  # 天空盒类实现
├── Shaders/
│   ├── skyboxVertex.glsl       # 天空盒顶点着色器
│   └── skyboxFragment.glsl     # 天空盒片段着色器
└── Textures/
    ├── skybox_summer/          # 夏季天空盒纹理
    │   ├── right.jpg           # +X 右
    │   ├── left.jpg            # -X 左
    │   ├── top.jpg             # +Y 上
    │   ├── bottom.jpg          # -Y 下
    │   ├── front.jpg           # +Z 前
    │   └── back.jpg            # -Z 后
    └── skybox_winter/          # 冬季天空盒纹理
        ├── right.jpg
        ├── left.jpg
        ├── top.jpg
        ├── bottom.jpg
        ├── front.jpg
        └── back.jpg
```

---

## 💻 代码实现

### 1. Skybox 类设计

**Skybox.h**
```cpp
#pragma once
#include <glad/glad.h>
#include <glm/glm.hpp>
#include <string>
#include <vector>

class Shader; // 前向声明

class Skybox {
public:
    // 构造函数：加载6张天空盒纹理
    Skybox(const std::vector<std::string>& faces);

    // 析构函数
    ~Skybox();

    // 渲染天空盒
    void Draw(Shader& shader, const glm::mat4& view, const glm::mat4& projection);

    // 获取立方体贴图ID（用于环境映射）
    GLuint GetCubemapID() const { return cubemapTexture; }

private:
    GLuint VAO, VBO;           // 顶点数组对象和顶点缓冲对象
    GLuint cubemapTexture;     // 立方体纹理ID

    // 初始化天空盒立方体
    void setupSkybox();

    // 加载立方体贴图
    GLuint loadCubemap(const std::vector<std::string>& faces);
};
```

**主要功能：**
- `Skybox(faces)` - 构造时加载6张纹理
- `Draw()` - 渲染天空盒
- `GetCubemapID()` - 返回纹理ID（供环境映射使用）

---

### 2. 着色器设计

#### skyboxVertex.glsl
```glsl
#version 330 core
layout (location = 0) in vec3 aPos;

out vec3 TexCoords;  // 输出给片段着色器的纹理坐标（3D方向向量）

uniform mat4 projection;
uniform mat4 view;

void main()
{
    TexCoords = aPos;  // 直接使用顶点位置作为采样方向

    // 关键技巧1：去除view矩阵的平移分量
    mat4 viewWithoutTranslation = mat4(mat3(view));

    vec4 pos = projection * viewWithoutTranslation * vec4(aPos, 1.0);

    // 关键技巧2：设置深度为1.0（最远）
    gl_Position = pos.xyww;  // 透视除法后 z/w = w/w = 1.0
}
```

**关键点：**
- `TexCoords = aPos` - 使用顶点位置作为方向向量
- `mat4(mat3(view))` - 去除平移，只保留旋转
- `pos.xyww` - 确保深度值为1.0

#### skyboxFragment.glsl
```glsl
#version 330 core
out vec4 FragColor;

in vec3 TexCoords;  // 从顶点着色器接收的方向向量

uniform samplerCube skybox;  // 立方体纹理采样器

void main()
{
    // 使用3D方向向量采样立方体贴图
    FragColor = texture(skybox, TexCoords);
}
```

**关键点：**
- `samplerCube` - 立方体纹理采样器类型
- `texture(skybox, TexCoords)` - 使用3D向量采样

---

### 3. 立方体顶点数据

天空盒是一个**以原点为中心的单位立方体**：

```cpp
// 在Skybox.cpp的setupSkybox()中
float skyboxVertices[] = {
    // 位置坐标（36个顶点，6个面，每面2个三角形）
    // 后面 (Back face, -Z)
    -1.0f,  1.0f, -1.0f,
    -1.0f, -1.0f, -1.0f,
     1.0f, -1.0f, -1.0f,
     1.0f, -1.0f, -1.0f,
     1.0f,  1.0f, -1.0f,
    -1.0f,  1.0f, -1.0f,

    // 左面 (Left face, -X)
    -1.0f, -1.0f,  1.0f,
    -1.0f, -1.0f, -1.0f,
    -1.0f,  1.0f, -1.0f,
    -1.0f,  1.0f, -1.0f,
    -1.0f,  1.0f,  1.0f,
    -1.0f, -1.0f,  1.0f,

    // 右面 (Right face, +X)
     1.0f, -1.0f, -1.0f,
     1.0f, -1.0f,  1.0f,
     1.0f,  1.0f,  1.0f,
     1.0f,  1.0f,  1.0f,
     1.0f,  1.0f, -1.0f,
     1.0f, -1.0f, -1.0f,

    // 前面 (Front face, +Z)
    -1.0f, -1.0f,  1.0f,
    -1.0f,  1.0f,  1.0f,
     1.0f,  1.0f,  1.0f,
     1.0f,  1.0f,  1.0f,
     1.0f, -1.0f,  1.0f,
    -1.0f, -1.0f,  1.0f,

    // 上面 (Top face, +Y)
    -1.0f,  1.0f, -1.0f,
     1.0f,  1.0f, -1.0f,
     1.0f,  1.0f,  1.0f,
     1.0f,  1.0f,  1.0f,
    -1.0f,  1.0f,  1.0f,
    -1.0f,  1.0f, -1.0f,

    // 下面 (Bottom face, -Y)
    -1.0f, -1.0f, -1.0f,
    -1.0f, -1.0f,  1.0f,
     1.0f, -1.0f, -1.0f,
     1.0f, -1.0f, -1.0f,
    -1.0f, -1.0f,  1.0f,
     1.0f, -1.0f,  1.0f
};
```

---

### 4. 立方体贴图加载

```cpp
GLuint Skybox::loadCubemap(const std::vector<std::string>& faces) {
    GLuint textureID;
    glGenTextures(1, &textureID);
    glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);

    // 加载6张纹理
    int width, height, nrChannels;
    for (unsigned int i = 0; i < faces.size(); i++) {
        unsigned char* data = stbi_load(faces[i].c_str(), &width, &height, &nrChannels, 0);
        if (data) {
            GLenum format = (nrChannels == 3) ? GL_RGB : GL_RGBA;

            // 注意：使用GL_TEXTURE_CUBE_MAP_POSITIVE_X + i
            glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i,
                         0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data);
            stbi_image_free(data);
        } else {
            std::cout << "立方体贴图纹理加载失败: " << faces[i] << std::endl;
            stbi_image_free(data);
        }
    }

    // 设置纹理参数
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);

    return textureID;
}
```

**关键点：**
- `GL_TEXTURE_CUBE_MAP` - 立方体纹理目标
- `GL_TEXTURE_CUBE_MAP_POSITIVE_X + i` - 6个面的枚举值是连续的
- `GL_CLAMP_TO_EDGE` - 防止接缝处出现伪影

---

### 5. 主程序集成

**在 main.cpp 中：**

```cpp
// 1. 加载着色器
Shader skyboxShader("Shaders/skyboxVertex.glsl", "Shaders/skyboxFragment.glsl");

// 2. 准备天空盒纹理路径（注意顺序）
std::vector<std::string> summerSkybox = {
    "Textures/skybox_summer/right.jpg",   // +X
    "Textures/skybox_summer/left.jpg",    // -X
    "Textures/skybox_summer/top.jpg",     // +Y
    "Textures/skybox_summer/bottom.jpg",  // -Y
    "Textures/skybox_summer/front.jpg",   // +Z
    "Textures/skybox_summer/back.jpg"     // -Z
};

// 3. 创建天空盒对象
Skybox skybox(summerSkybox);

// 4. 渲染循环
while (!window.ShouldClose()) {
    // ... 处理输入 ...

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // 渲染地形和其他物体
    // ...

    // 最后渲染天空盒
    glDepthFunc(GL_LEQUAL);  // 允许深度值为1.0通过
    skybox.Draw(skyboxShader, camera.GetViewMatrix(), projection);
    glDepthFunc(GL_LESS);    // 恢复默认深度测试

    window.SwapBuffers();
}
```

---

## 🖼️ 资源准备

### 天空盒纹理要求

1. **图片数量**：6张（上、下、左、右、前、后）
2. **图片尺寸**：所有图片必须相同（推荐：1024x1024 或 2048x2048）
3. **图片格式**：JPG 或 PNG
4. **命名规范**：建议使用统一命名（right, left, top, bottom, front, back）

### 纹理对应关系

```
文件名        OpenGL枚举                    方向
right.jpg  -> POSITIVE_X (+X)  -> 右
left.jpg   -> NEGATIVE_X (-X)  -> 左
top.jpg    -> POSITIVE_Y (+Y)  -> 上
bottom.jpg -> NEGATIVE_Y (-Y)  -> 下
front.jpg  -> POSITIVE_Z (+Z)  -> 前
back.jpg   -> NEGATIVE_Z (-Z)  -> 后
```

### 推荐资源网站

#### 1. **Poly Haven** (最推荐)
- 网址：https://polyhaven.com/hdris
- 优点：免费，质量高，CC0许可
- 下载步骤：
  1. 选择HDRI → Download
  2. 选择"Skybox (JPG)" → 下载ZIP
  3. 解压后得到6张图片

#### 2. **LearnOpenGL**
- 网址：https://learnopengl.com/Advanced-OpenGL/Cubemaps
- 提供示例天空盒下载

#### 3. **Humus**
- 网址：http://www.humus.name/index.php?page=Textures
- 大量免费天空盒

### 天空盒主题建议

**夏季场景：**
- ☀️ 晴朗蓝天 + 白云
- 🌅  黄昏天空（金黄色）
- 🌄  清晨天空（粉色调）

**冬季场景：**
- ❄️ 阴天灰云
- 🌨️ 雪天天空（白灰色）
- 🌃 冬季傍晚（蓝灰色）

---

## 🐛 常见问题与解决

### 问题1：天空盒有接缝
**现象：** 立方体边缘处有明显的接缝线

**原因：** 纹理采样跨越边界时出现问题

**解决方案：**
```cpp
// 使用GL_CLAMP_TO_EDGE防止接缝
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
```

### 问题2：天空盒被地形遮挡
**现象：** 天空盒部分或全部不可见

**原因：** 渲染顺序或深度测试设置错误

**解决方案：**
```cpp
// 确保最后渲染天空盒
glDepthFunc(GL_LEQUAL);  // 允许深度值为1.0通过
skybox.Draw(...);
glDepthFunc(GL_LESS);
```

### 问题3：天空盒跟随相机移动
**现象：** 移动相机时，天空盒也在移动

**原因：** 没有去除view矩阵的平移分量

**解决方案：**
```glsl
// 在顶点着色器中
mat4 viewWithoutTranslation = mat4(mat3(view));
```

### 问题4：天空盒颜色不对
**现象：** 天空盒颜色偏暗或偏亮

**原因：** 纹理颜色空间问题

**检查：**
```cpp
// 确认纹理格式
GLenum format = (nrChannels == 3) ? GL_RGB : GL_RGBA;
glTexImage2D(..., format, ..., format, ...);
```

### 问题5：纹理加载失败
**现象：** 控制台提示"立方体贴图纹理加载失败"

**检查清单：**
- ✅ 文件路径是否正确（相对于exe的工作目录）
- ✅ 文件是否存在
- ✅ 文件格式是否为JPG/PNG
- ✅ 文件是否损坏

---

## ✅ 实施步骤

### 第1步：准备资源（30分钟）
1. 访问 Poly Haven
2. 下载夏季天空盒（6张图）
3. 下载冬季天空盒（6张图）
4. 创建文件夹 `Textures/skybox_summer/` 和 `Textures/skybox_winter/`
5. 重命名图片为：right.jpg, left.jpg, top.jpg, bottom.jpg, front.jpg, back.jpg

### 第2步：创建Skybox类（1-2小时）
1. 创建 `Skybox.h` 和 `Skybox.cpp`
2. 实现立方体顶点数据
3. 实现立方体贴图加载
4. 实现Draw方法

### 第3步：编写着色器（30分钟）
1. 创建 `Shaders/skyboxVertex.glsl`
2. 创建 `Shaders/skyboxFragment.glsl`
3. 实现去平移和深度技巧

### 第4步：集成到主程序（30分钟）
1. 在 `main.cpp` 中加载天空盒着色器
2. 创建Skybox对象
3. 在渲染循环中渲染天空盒
4. 调整渲染顺序

### 第5步：测试和调试（30分钟）
1. 运行程序检查效果
2. 测试相机移动（天空盒应该跟随旋转，不跟随平移）
3. 检查是否有接缝
4. 调整深度测试设置

---

## 🎯 验收标准

完成后，你的天空盒系统应该满足：

- ✅ 天空盒正确渲染，无接缝
- ✅ 天空盒始终在场景最远处
- ✅ 相机旋转时，天空盒跟随旋转
- ✅ 相机移动时，天空盒保持静止（无限远的感觉）
- ✅ 夏季天空盒和冬季天空盒都能正常加载
- ✅ 可以通过按键切换天空盒（为后续时间转换准备）

---

## 📈 下一步扩展

完成基础天空盒后，可以实现：

### 1. 天空盒切换功能
```cpp
// 在main.cpp中添加
Skybox summerSkybox(summerFaces);
Skybox winterSkybox(winterFaces);
bool isSummer = true;

// 渲染时
if (isSummer)
    summerSkybox.Draw(...);
else
    winterSkybox.Draw(...);

// 按键切换
if (key == GLFW_KEY_T) {
    isSummer = !isSummer;
}
```

### 2. 环境映射（水面反射）
```cpp
// 在片段着色器中
vec3 I = normalize(Position - cameraPos);
vec3 R = reflect(I, normalize(Normal));
vec4 reflectColor = texture(skybox, R);
```

### 3. 动态天空（云朵移动）
```glsl
// 在片段着色器中添加时间偏移
vec3 adjustedCoords = TexCoords + vec3(time * 0.01, 0.0, 0.0);
FragColor = texture(skybox, adjustedCoords);
```

---

## 📝 总结

天空盒系统是现代3D游戏的标配功能，实现后会极大提升场景的视觉效果。通过本文档，你应该能够：

1. ✅ 理解立方体贴图的工作原理
2. ✅ 掌握天空盒的渲染技巧
3. ✅ 独立实现完整的天空盒系统
4. ✅ 为环境映射功能奠定基础

**下一步：** 完成天空盒后，立即进行**镜面光照**的完善，然后开始**OBJ模型加载系统**。

加油！🚀
