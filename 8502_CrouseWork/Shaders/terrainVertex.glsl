// ========================================
// 地形顶点着色器
// ========================================
// 功能：
// 1. 将顶点从模型空间变换到裁剪空间
// 2. 传递法向量和纹理坐标给片段着色器
// 3. 计算世界空间中的顶点位置（用于光照）
// ========================================

#version 330 core

// ========================================
// 输入：从Terrain.cpp传来的顶点属性
// ========================================
layout(location = 0) in vec3 aPos;      // 顶点位置
layout(location = 1) in vec3 aNormal;   // 顶点法向量
layout(location = 2) in vec2 aTexCoord; // 纹理坐标

// ========================================
// 输出：传递给片段着色器的数据
// ========================================
out vec3 FragPos;       // 片段在世界空间中的位置
out vec3 Normal;        // 法向量（世界空间）
out vec2 TexCoord;      // 纹理坐标

// ========================================
// Uniform变量：从C++代码传入的变换矩阵
// ========================================
uniform mat4 model;         // 模型矩阵：模型空间 → 世界空间
uniform mat4 view;          // 视图矩阵：世界空间 → 相机空间
uniform mat4 projection;    // 投影矩阵：相机空间 → 裁剪空间

// ========================================
// 主函数：顶点着色器的入口点
// ========================================
void main()
{
    // ========================================
    // 1. 计算片段的世界空间位置
    // ========================================
    // model * vec4(aPos, 1.0) 将顶点从模型空间变换到世界空间
    // 这个位置会传给片段着色器，用于光照计算
    FragPos = vec3(model * vec4(aPos, 1.0));

    // ========================================
    // 2. 变换法向量到世界空间
    // ========================================
    // 注意：法向量的变换需要特殊处理！
    //
    // 为什么用 transpose(inverse(model))？
    // - 如果model矩阵包含非均匀缩放（如x缩放2倍，y缩放1倍）
    //   直接用model变换法向量会导致法向量方向错误
    // - transpose(inverse(model)) 是法向量的正确变换矩阵
    // - 如果model只包含旋转和平移，用model也可以
    //
    // mat3(...)：只取左上角3x3部分，因为法向量是方向，不需要平移
    Normal = mat3(transpose(inverse(model))) * aNormal;

    // ========================================
    // 3. 传递纹理坐标（不需要变换）
    // ========================================
    TexCoord = aTexCoord;

    // ========================================
    // 4. 计算最终顶点位置（裁剪空间）
    // ========================================
    // 变换流程：
    //   模型空间 (aPos)
    //     ↓ model
    //   世界空间
    //     ↓ view
    //   相机空间（观察空间）
    //     ↓ projection
    //   裁剪空间 (gl_Position)
    //
    // OpenGL会自动进行透视除法，将裁剪空间转为NDC（归一化设备坐标）
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}
