# 水面渲染系统 - 实现方案

**目标**：为海洋主题天空盒场景添加真实的水平面，解决地形悬浮问题

**日期**：2025-10-29
**优先级**：⭐⭐⭐ 高（影响视觉效果和环境映射功能）

---

## 🎯 问题分析

### 当前问题
1. ✅ 海洋主题天空盒已完成（底部是海洋）
2. ❌ 地形 Y 轴高度比天空盒底部高
3. ❌ 看起来像陆地悬浮在海洋上
4. ❌ 缺少真实的水平面

### 解决方向
1. **调整地形高度映射** - 让地形有高有低，部分在水面下
2. **创建水平面系统** - 实现可交互、有视觉效果的水面
3. **实现水面效果** - 反射、折射、波浪动画

---

## 📋 实现方案（三个版本）

### 方案对比

| 方案 | 难度 | 实现时间 | 视觉效果 | 推荐度 |
|------|------|----------|----------|--------|
| **方案1：基础水面** | 低 | 0.5天 | ⭐⭐ | 适合快速原型 |
| **方案2：反射水面** | 中 | 1-1.5天 | ⭐⭐⭐⭐ | ⭐⭐⭐ 推荐 |
| **方案3：完整水面** | 高 | 2-3天 | ⭐⭐⭐⭐⭐ | 时间充足时 |

---

## 🚀 方案1：基础水面（快速实现）

**特点**：简单、快速、满足基本需求

### 实现内容

#### 1. 调整地形高度
```cpp
// 在 Terrain.cpp 的高度计算中调整
float height = pixelValue * heightScale - heightOffset;
// 推荐参数：
// heightScale = 20.0f（原来可能是30-50）
// heightOffset = 10.0f（新增，让地形有负值区域）
```

**效果**：地形有的地方在水面上（岛屿），有的地方在水面下（海底）

#### 2. 创建简单水平面
创建 `WaterPlane` 类：

**文件结构：**
- `WaterPlane.h` - 水面类声明
- `WaterPlane.cpp` - 水面类实现
- `Shaders/waterVertex.glsl` - 水面顶点着色器
- `Shaders/waterFragment.glsl` - 水面片段着色器

**WaterPlane 类（简化版）：**
```cpp
class WaterPlane {
private:
    unsigned int VAO, VBO, EBO;
    float waterLevel;  // 水面高度 (如 Y = 0.0)
    float waterSize;   // 水面大小 (如 500x500)

public:
    WaterPlane(float level, float size);
    void Render(Shader& shader);
};
```

#### 3. 水面着色器（基础版）

**顶点着色器：**
```glsl
#version 330 core
layout(location = 0) in vec3 aPos;
layout(location = 1) in vec2 aTexCoord;

out vec2 TexCoord;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
uniform float time;  // 用于波浪动画

void main() {
    vec3 pos = aPos;

    // 简单的正弦波浪
    pos.y += sin(pos.x * 0.5 + time) * 0.3;
    pos.y += cos(pos.z * 0.5 + time) * 0.3;

    gl_Position = projection * view * model * vec4(pos, 1.0);
    TexCoord = aTexCoord;
}
```

**片段着色器：**
```glsl
#version 330 core
out vec4 FragColor;

in vec2 TexCoord;

uniform sampler2D waterTexture;  // 水纹理（可选）
uniform vec3 waterColor;         // 水的颜色
uniform float alpha;             // 透明度

void main() {
    // 简单的蓝色水面
    vec3 color = waterColor; // vec3(0.1, 0.3, 0.5)

    FragColor = vec4(color, alpha);  // alpha = 0.6-0.8
}
```

#### 4. 渲染配置

**在 main.cpp 中的渲染顺序：**
```cpp
// 1. 渲染不透明物体
terrain.Render(terrainShader);

// 2. 启用混合模式
glEnable(GL_BLEND);
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

// 3. 渲染水面
waterPlane.Render(waterShader);

// 4. 关闭混合
glDisable(GL_BLEND);

// 5. 渲染天空盒
skybox.Render(skyboxShader);
```

### 优点
- ✅ 实现快速（半天）
- ✅ 代码简单
- ✅ 解决悬浮问题

### 缺点
- ❌ 无反射效果
- ❌ 视觉效果一般
- ❌ 不能用于环境映射演示

**预计时间：0.5天**

---

## 🌟 方案2：反射水面（推荐⭐）

**特点**：视觉效果好，满足课程要求（环境映射）

### 实现内容

#### 1. 水面反射原理
- 使用天空盒（Cubemap）作为环境贴图
- 计算视线到水面的反射向量
- 采样天空盒得到反射颜色
- 混合反射色和水的基础色

#### 2. WaterPlane 类（反射版）

```cpp
class WaterPlane {
private:
    unsigned int VAO, VBO, EBO;
    float waterLevel;
    float waterSize;

    // 水面网格（用于法向量计算）
    int gridResolution;  // 如 100x100

public:
    WaterPlane(float level, float size, int resolution);
    void Render(Shader& shader, unsigned int skyboxTexture);
    void Update(float deltaTime);  // 更新波浪
};
```

#### 3. 水面着色器（反射版）

**顶点着色器：**
```glsl
#version 330 core
layout(location = 0) in vec3 aPos;
layout(location = 1) in vec3 aNormal;
layout(location = 2) in vec2 aTexCoord;

out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoord;
out vec3 ViewDir;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
uniform vec3 viewPos;
uniform float time;

void main() {
    vec3 pos = aPos;

    // 更复杂的波浪（多个正弦波叠加）
    float wave1 = sin(pos.x * 0.3 + time * 0.5) * 0.2;
    float wave2 = cos(pos.z * 0.4 + time * 0.6) * 0.15;
    float wave3 = sin((pos.x + pos.z) * 0.2 + time * 0.4) * 0.1;
    pos.y += wave1 + wave2 + wave3;

    // 计算扰动后的法向量（近似）
    vec3 normal = aNormal;
    normal.x += cos(pos.x * 0.3 + time * 0.5) * 0.3;
    normal.z += sin(pos.z * 0.4 + time * 0.6) * 0.3;
    normal = normalize(normal);

    FragPos = vec3(model * vec4(pos, 1.0));
    Normal = mat3(transpose(inverse(model))) * normal;
    TexCoord = aTexCoord;
    ViewDir = viewPos - FragPos;

    gl_Position = projection * view * vec4(FragPos, 1.0);
}
```

**片段着色器：**
```glsl
#version 330 core
out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;
in vec2 TexCoord;
in vec3 ViewDir;

uniform samplerCube skybox;       // 天空盒立方体贴图
uniform sampler2D waterNormalMap; // 水的法线贴图（可选）
uniform vec3 waterColor;
uniform float time;

void main() {
    vec3 norm = normalize(Normal);
    vec3 viewDir = normalize(ViewDir);

    // 计算反射向量
    vec3 reflectDir = reflect(-viewDir, norm);

    // 从天空盒采样反射颜色
    vec3 reflectionColor = texture(skybox, reflectDir).rgb;

    // 水的基础颜色
    vec3 baseColor = waterColor; // vec3(0.1, 0.3, 0.5)

    // 计算菲涅尔效应（边缘更透明，中心更反射）
    float fresnel = pow(1.0 - max(dot(viewDir, norm), 0.0), 3.0);

    // 混合反射和基础色
    vec3 finalColor = mix(baseColor, reflectionColor, fresnel * 0.7);

    // 根据观察角度调整透明度
    float alpha = 0.7 + fresnel * 0.3;

    FragColor = vec4(finalColor, alpha);
}
```

#### 4. 渲染集成

```cpp
// 在 main.cpp 渲染循环中

// 1. 渲染天空盒（先渲染，用于反射）
skybox.Render(skyboxShader);

// 2. 渲染地形
terrain.Render(terrainShader);

// 3. 渲染反射水面
glEnable(GL_BLEND);
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
glDepthMask(GL_FALSE); // 不写入深度（水面半透明）

waterShader.Use();
waterShader.SetFloat("time", glfwGetTime());
waterShader.SetVec3("viewPos", camera.Position);
waterShader.SetVec3("waterColor", glm::vec3(0.1f, 0.3f, 0.5f));

// 绑定天空盒纹理用于反射
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_CUBE_MAP, skybox.GetTextureID());
waterShader.SetInt("skybox", 0);

waterPlane.Render(waterShader);

glDepthMask(GL_TRUE);
glDisable(GL_BLEND);
```

### 优点
- ✅ 视觉效果优秀
- ✅ 满足"环境映射"课程要求
- ✅ 有动态波浪
- ✅ 有菲涅尔效果

### 缺点
- ⚠️ 需要修改 Skybox 类暴露纹理 ID
- ⚠️ 需要调试反射效果

**预计时间：1-1.5天**

---

## 🎨 方案3：完整水面系统（高级）

**特点**：真实感最强，适合追求完美的情况

### 额外实现内容

#### 1. 双重渲染（反射 + 折射）
- **反射纹理**：渲染水面上方场景的倒影
- **折射纹理**：渲染水面下方场景的扭曲

**需要 2 个 FBO（帧缓冲对象）：**
```cpp
class WaterFrameBuffer {
private:
    unsigned int reflectionFBO;  // 反射帧缓冲
    unsigned int refractionFBO;  // 折射帧缓冲
    unsigned int reflectionTexture;
    unsigned int refractionTexture;

public:
    void BindReflectionFBO();
    void BindRefractionFBO();
    void UnbindFBO();
};
```

#### 2. 渲染流程

```cpp
// === 第1步：渲染反射纹理 ===
waterFBO.BindReflectionFBO();
camera.InvertPitch();  // 翻转相机
// 只渲染水面上方的物体（裁剪平面）
terrain.Render(terrainShader);
skybox.Render(skyboxShader);
camera.InvertPitch();  // 恢复相机

// === 第2步：渲染折射纹理 ===
waterFBO.BindRefractionFBO();
// 只渲染水面下方的物体（裁剪平面）
terrain.Render(terrainShader);

// === 第3步：渲染正常场景 + 水面 ===
waterFBO.UnbindFBO();
terrain.Render(terrainShader);

// 使用反射和折射纹理渲染水面
waterShader.Use();
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, waterFBO.reflectionTexture);
glActiveTexture(GL_TEXTURE1);
glBindTexture(GL_TEXTURE_2D, waterFBO.refractionTexture);
waterPlane.Render(waterShader);

skybox.Render(skyboxShader);
```

#### 3. 完整水面着色器

**片段着色器：**
```glsl
#version 330 core
out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;
in vec2 TexCoord;
in vec4 ClipSpace;

uniform sampler2D reflectionTexture;
uniform sampler2D refractionTexture;
uniform sampler2D dudvMap;         // DuDv 贴图（扭曲）
uniform sampler2D normalMap;       // 法线贴图
uniform float moveFactor;          // 波浪移动因子
uniform vec3 viewPos;

void main() {
    // 归一化设备坐标
    vec2 ndc = (ClipSpace.xy / ClipSpace.w) * 0.5 + 0.5;

    // DuDv 扭曲（模拟波浪）
    vec2 distortion = texture(dudvMap, vec2(TexCoord.x + moveFactor, TexCoord.y)).rg * 0.1;
    distortion = TexCoord + vec2(distortion.x, distortion.y + moveFactor);
    vec2 totalDistortion = (texture(dudvMap, distortion).rg * 2.0 - 1.0) * 0.02;

    // 采样反射和折射纹理
    vec2 reflectCoords = vec2(ndc.x, 1.0 - ndc.y) + totalDistortion;
    vec2 refractCoords = ndc + totalDistortion;
    reflectCoords = clamp(reflectCoords, 0.001, 0.999);
    refractCoords = clamp(refractCoords, 0.001, 0.999);

    vec4 reflectColor = texture(reflectionTexture, reflectCoords);
    vec4 refractColor = texture(refractionTexture, refractCoords);

    // 菲涅尔效应
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 normal = texture(normalMap, distortion).rgb;
    normal = normalize(normal * 2.0 - 1.0);
    float fresnel = pow(1.0 - dot(viewDir, vec3(0, 1, 0)), 2.0);

    // 混合反射和折射
    vec4 finalColor = mix(reflectColor, refractColor, fresnel);

    // 添加轻微的蓝色调
    finalColor = mix(finalColor, vec4(0.0, 0.3, 0.5, 1.0), 0.2);

    FragColor = finalColor;
}
```

### 优点
- ✅ 真实感极强
- ✅ 动态反射折射
- ✅ 可以看到水下地形

### 缺点
- ❌ 实现复杂
- ❌ 性能开销大
- ❌ 调试困难

**预计时间：2-3天**

---

## 📊 推荐实施路线

### 🎯 推荐：**渐进式实现**

**第1阶段（0.5天）：快速解决悬浮问题**
1. 调整地形高度参数（让部分地形在水面下）
2. 实现方案1（基础水面）
3. **目标**：场景看起来合理

**第2阶段（1天）：添加反射效果**
1. 升级到方案2（反射水面）
2. 集成天空盒反射
3. **目标**：满足"环境映射"要求

**第3阶段（可选，1-2天）：追求完美**
1. 如果时间充足，升级到方案3
2. **目标**：视觉效果最佳

---

## 🛠️ 具体实施步骤（方案2）

### Step 1: 调整地形高度（15分钟）

**修改 `Terrain.cpp`：**
```cpp
// 在生成地形的循环中
float pixelValue = heightData[index] / 255.0f;

// 原来：
// float height = pixelValue * 30.0f;

// 改为：
float heightScale = 20.0f;
float heightOffset = 8.0f;  // 让水面处于 Y = 0
float height = pixelValue * heightScale - heightOffset;

// 这样高度范围：-8.0 到 12.0
// 水面设在 Y = 0.0
```

### Step 2: 创建 WaterPlane 类（1小时）

**创建文件：**
- `8502_CrouseWork/WaterPlane.h`
- `8502_CrouseWork/WaterPlane.cpp`

**WaterPlane.h 基本结构：**
```cpp
#ifndef WATERPLANE_H
#define WATERPLANE_H

#include <glad/glad.h>
#include <glm/glm.hpp>
#include "Shader.h"

class WaterPlane {
public:
    WaterPlane(float level, float size, int resolution);
    ~WaterPlane();

    void Render(Shader& shader);
    void Update(float deltaTime);

private:
    unsigned int VAO, VBO, EBO;
    float waterLevel;
    float size;
    int resolution;
    int indexCount;

    void GenerateMesh();
};

#endif
```

### Step 3: 编写水面着色器（30分钟）

**创建文件：**
- `8502_CrouseWork/Shaders/waterVertex.glsl`
- `8502_CrouseWork/Shaders/waterFragment.glsl`

（使用上面方案2的着色器代码）

### Step 4: 修改 Skybox 类（15分钟）

**在 `Skybox.h` 中添加：**
```cpp
class Skybox {
public:
    // ... 现有方法 ...

    // 新增：返回立方体贴图纹理ID
    unsigned int GetTextureID() const { return textureID; }

private:
    unsigned int textureID;  // 确保有这个成员
};
```

### Step 5: 集成到 main.cpp（30分钟）

```cpp
// 1. 包含头文件
#include "WaterPlane.h"

// 2. 初始化水面
WaterPlane waterPlane(0.0f, 1000.0f, 100);  // 水面高度0，大小1000x1000，分辨率100
Shader waterShader("Shaders/waterVertex.glsl", "Shaders/waterFragment.glsl");

// 3. 渲染循环中添加
// ... 渲染地形 ...

// 渲染水面
glEnable(GL_BLEND);
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

waterShader.Use();
waterShader.SetMat4("model", glm::mat4(1.0f));
waterShader.SetMat4("view", camera.GetViewMatrix());
waterShader.SetMat4("projection", projection);
waterShader.SetVec3("viewPos", camera.Position);
waterShader.SetFloat("time", glfwGetTime());
waterShader.SetVec3("waterColor", glm::vec3(0.1f, 0.3f, 0.5f));

// 绑定天空盒纹理
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_CUBE_MAP, skybox.GetTextureID());
waterShader.SetInt("skybox", 0);

waterPlane.Render(waterShader);

glDisable(GL_BLEND);

// ... 渲染天空盒 ...
```

### Step 6: 测试和调优（1-2小时）

**调试检查清单：**
- [ ] 水面位置是否正确（Y = 0）
- [ ] 地形是否部分在水面下
- [ ] 水面是否半透明
- [ ] 反射效果是否可见
- [ ] 波浪动画是否流畅
- [ ] 不同角度观察效果

**常见参数调整：**
```cpp
// 水面颜色
waterColor = vec3(0.05, 0.2, 0.4);  // 深海蓝
waterColor = vec3(0.1, 0.4, 0.6);   // 浅海蓝
waterColor = vec3(0.0, 0.5, 0.5);   // 青绿色

// 透明度
alpha = 0.6;  // 更透明
alpha = 0.8;  // 更不透明

// 波浪幅度
pos.y += sin(...) * 0.1;  // 平静水面
pos.y += sin(...) * 0.5;  // 波涛汹涌
```

---

## 📦 所需资源

### 纹理资源（可选）
1. **水法线贴图** - 用于更真实的波浪
   - 搜索："water normal map"
   - 推荐网站：[Poly Haven](https://polyhaven.com/textures?c=water)

2. **DuDv 贴图** - 用于扭曲效果（方案3）
   - 搜索："water dudv map"
   - [LearnOpenGL 教程](https://learnopengl.com/)有提供

### 不需要额外资源
- ✅ 天空盒已有（用于反射）
- ✅ 着色器代码本文档提供
- ✅ 基础水面不需要纹理

---

## ⏱️ 时间估算

### 方案2（推荐）详细时间：
| 任务 | 预计时间 | 说明 |
|------|----------|------|
| 调整地形高度 | 15分钟 | 修改几行代码 |
| 创建 WaterPlane 类 | 1小时 | 网格生成逻辑 |
| 编写水面着色器 | 30分钟 | 复制粘贴 + 调整 |
| 修改 Skybox 类 | 15分钟 | 添加 getter |
| 集成到 main.cpp | 30分钟 | 渲染流程 |
| 测试和调优 | 1-2小时 | 参数调整 |
| **总计** | **4-5小时（约半天到1天）** | |

---

## 🎯 成功标准

完成后应该达到的效果：

### 视觉效果
- [x] 地形有岛屿露出水面
- [x] 地形有部分在水面下（海底）
- [x] 水面呈现蓝色半透明
- [x] 水面有动态波浪
- [x] 水面反射天空盒（海洋）
- [x] 从不同角度看效果自然

### 技术指标
- [x] 满足"环境映射"课程要求
- [x] 帧率稳定（>30 FPS）
- [x] 无明显渲染错误
- [x] 代码有详细注释

---

## 🔍 常见问题排查

### Q1: 水面不透明？
```cpp
// 确保启用了混合
glEnable(GL_BLEND);
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

// 着色器输出 alpha < 1.0
FragColor = vec4(color, 0.7);
```

### Q2: 看不到反射？
```cpp
// 检查天空盒纹理是否正确绑定
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_CUBE_MAP, skyboxTextureID);

// 检查采样器 uniform
waterShader.SetInt("skybox", 0);
```

### Q3: 波浪不动？
```cpp
// 确保传入时间 uniform
waterShader.SetFloat("time", glfwGetTime());
```

### Q4: 水面闪烁？
```cpp
// Z-fighting 问题，调整水面高度
waterLevel = 0.05f;  // 稍微高一点
// 或启用多边形偏移
glEnable(GL_POLYGON_OFFSET_FILL);
glPolygonOffset(-1.0f, -1.0f);
```

---

## 📚 参考资料

### 推荐教程
1. **LearnOpenGL - Cubemaps**
   - https://learnopengl.com/Advanced-OpenGL/Cubemaps
   - 环境映射原理

2. **LearnOpenGL - Framebuffers**
   - https://learnopengl.com/Advanced-OpenGL/Framebuffers
   - 反射折射实现（方案3）

3. **ThinMatrix Water Tutorial**
   - YouTube: "OpenGL Water Tutorial"
   - 完整的水面渲染教程

### 代码参考
- 本项目现有系统：
  - `Terrain.cpp` - 网格生成参考
  - `Skybox.cpp` - 立方体贴图使用
  - `Shader.cpp` - 着色器系统

---

## 🚀 下一步行动

### 立即开始（推荐顺序）：

1. **先快速测试**（15分钟）
   ```cpp
   // 在 Terrain.cpp 中调整高度
   float height = pixelValue * 20.0f - 8.0f;
   ```
   运行程序，看地形是否有起伏

2. **创建基础水面**（1小时）
   - 创建 WaterPlane 类
   - 实现简单蓝色平面
   - 测试渲染

3. **添加反射效果**（2小时）
   - 编写反射着色器
   - 集成天空盒纹理
   - 调试效果

4. **优化和完善**（1-2小时）
   - 添加波浪动画
   - 调整颜色和透明度
   - 测试不同视角

---

## 💡 实施建议

### 优先级顺序
1. ⭐⭐⭐ **先解决悬浮问题**（调整地形高度）
2. ⭐⭐⭐ **快速添加基础水面**（方案1）
3. ⭐⭐ **升级到反射水面**（方案2）- 满足课程要求
4. ⭐ **如时间充足再考虑方案3**

### 风险控制
- 每完成一步就保存代码（Git commit）
- 遇到问题先回退到上一个工作版本
- 不要一次性写完所有代码，逐步测试

### 课程要求匹配
- ✅ **环境映射演示** - 方案2即可满足
- ✅ **纹理映射** - 水面使用天空盒纹理
- ✅ **视觉效果** - 动态波浪 + 反射

---

## 🎉 预期效果

完成后你将拥有：
- 🌊 一个漂亮的海洋场景
- 🏝️ 岛屿地形（部分露出水面）
- 💧 真实的反射水面
- 🌅 水面反射海洋天空盒
- ✅ 满足"环境映射"课程要求

---

**准备好开始了吗？告诉我你想从哪里开始，我会立即帮你实现！** 🚀
