# 模型加载测试指南

## 📝 准备工作

### 1. 准备测试模型

在开始之前，你需要一个OBJ模型文件用于测试。

**方法1：下载免费模型**
- 访问 Sketchfab：https://sketchfab.com/
- 搜索 "tree low poly" 或 "rock"
- 筛选 CC License（免费）
- 下载格式选择 **OBJ**

**方法2：使用简单的测试模型**
如果你还没有模型，可以先用一个简单的立方体OBJ文件测试。我会在下面提供一个。

### 2. 创建Models目录

```bash
# 在项目根目录执行
mkdir 8502_CrouseWork\Models
```

将下载的模型文件放到这个目录下，例如：
```
8502_CrouseWork\Models\tree.obj
8502_CrouseWork\Models\rock.obj
```

---

## 🧪 测试方案

我们分3个阶段测试：

### 阶段1：编译测试（确保代码没有错误）
### 阶段2：加载测试（测试能否成功加载OBJ文件）
### 阶段3：渲染测试（测试能否在场景中显示模型）

---

## 阶段1：编译测试

### 1.1 打开Visual Studio

打开 `8502_CrouseWork.sln`

### 1.2 确认文件已添加

在 Solution Explorer 中，你应该看到：
- **Header Files**
  - ✅ Mesh.h
  - ✅ Model.h
- **Source Files**
  - ✅ Mesh.cpp
  - ✅ Model.cpp

### 1.3 编译项目

按 **F7** 或者 **Build → Build Solution**

**预期结果：**
```
Build succeeded.
0 Warning(s)
0 Error(s)
```

**如果有错误：**
- 检查是否已经配置了TinyOBJ的include路径
- 检查IncludePath是否包含 `$(ProjectDir)Dependencies\TinyOBJ`

---

## 阶段2：加载测试

### 2.1 准备一个简单的测试OBJ文件

如果你还没有模型，创建一个简单的测试文件：

**文件：** `8502_CrouseWork\Models\cube.obj`

```obj
# Simple Cube
v -1.0 -1.0  1.0
v  1.0 -1.0  1.0
v  1.0  1.0  1.0
v -1.0  1.0  1.0
v -1.0 -1.0 -1.0
v  1.0 -1.0 -1.0
v  1.0  1.0 -1.0
v -1.0  1.0 -1.0

vn  0.0  0.0  1.0
vn  0.0  0.0 -1.0
vn  0.0  1.0  0.0
vn  0.0 -1.0  0.0
vn  1.0  0.0  0.0
vn -1.0  0.0  0.0

vt 0.0 0.0
vt 1.0 0.0
vt 1.0 1.0
vt 0.0 1.0

# Front face
f 1/1/1 2/2/1 3/3/1
f 1/1/1 3/3/1 4/4/1

# Back face
f 5/1/2 6/2/2 7/3/2
f 5/1/2 7/3/2 8/4/2

# Top face
f 4/1/3 3/2/3 7/3/3
f 4/1/3 7/3/3 8/4/3

# Bottom face
f 1/1/4 2/2/4 6/3/4
f 1/1/4 6/3/4 5/4/4

# Right face
f 2/1/5 6/2/5 7/3/5
f 2/1/5 7/3/5 3/4/5

# Left face
f 1/1/6 5/2/6 8/3/6
f 1/1/6 8/3/6 4/4/6
```

### 2.2 修改main.cpp添加测试代码

在 `main()` 函数中，**在进入渲染循环之前**，添加以下代码：

```cpp
// ========================================
// 测试：加载OBJ模型
// ========================================
std::cout << "\n=== 开始测试模型加载 ===" << std::endl;

Model testModel("Models/cube.obj");  // 使用你的模型文件名

if (testModel.IsLoaded())
{
    std::cout << "✓ 模型加载成功！" << std::endl;
    std::cout << "网格数量: " << testModel.GetMeshCount() << std::endl;
}
else
{
    std::cerr << "✗ 模型加载失败！检查文件路径。" << std::endl;
    // 不退出程序，继续运行以便调试
}

std::cout << "=== 模型加载测试完成 ===\n" << std::endl;
```

**完整的位置示例：**

```cpp
int main()
{
    // ========================================
    // 1. 初始化GLFW和窗口
    // ========================================
    Window window(1920, 1080, "CSC8502 Coursework");
    if (!window.IsValid())
        return -1;

    // ========================================
    // 2. 加载着色器
    // ========================================
    Shader terrainShader("Shaders/terrainVertex.glsl", "Shaders/terrainFragment.glsl");
    // ... 其他初始化代码 ...

    // ========================================
    // 3. 【新增】测试模型加载
    // ========================================
    std::cout << "\n=== 开始测试模型加载 ===" << std::endl;

    Model testModel("Models/cube.obj");

    if (testModel.IsLoaded())
    {
        std::cout << "✓ 模型加载成功！" << std::endl;
        std::cout << "网格数量: " << testModel.GetMeshCount() << std::endl;
    }
    else
    {
        std::cerr << "✗ 模型加载失败！" << std::endl;
    }

    std::cout << "=== 模型加载测试完成 ===\n" << std::endl;

    // ========================================
    // 4. 渲染循环
    // ========================================
    while (!window.ShouldClose())
    {
        // ... 渲染代码 ...
    }

    return 0;
}
```

### 2.3 编译并运行

按 **F5** 运行程序（Debug模式）

### 2.4 查看控制台输出

**成功的输出应该类似于：**

```
=== 开始测试模型加载 ===

========================================
开始加载模型: Models/cube.obj
========================================
[LoadOBJ] 文件解析成功
  - 顶点数: 8
  - 法向量数: 6
  - 纹理坐标数: 4
  - 形状数: 1

[LoadOBJ] 处理形状 1 (Cube)
  - 顶点: 36, 三角形: 12
[Mesh] 创建网格：36 顶点, 12 三角形
  - VAO: 5, VBO: 6, EBO: 7
✓ 模型加载成功！
  - 网格数量: 1
========================================

✓ 模型加载成功！
网格数量: 1
=== 模型加载测试完成 ===
```

**如果失败：**

```
========================================
开始加载模型: Models/cube.obj
========================================
错误: Failed to open file
无法加载OBJ文件: Models/cube.obj
✗ 模型加载失败！
========================================

✗ 模型加载失败！
=== 模型加载测试完成 ===
```

**失败的可能原因：**
1. **文件路径错误** - 确保工作目录是项目根目录
2. **文件不存在** - 检查Models文件夹是否存在，模型文件是否在里面
3. **文件名错误** - 检查大小写（Windows不区分，但最好保持一致）

**调试方法：**

```cpp
// 打印当前工作目录
#include <filesystem>
std::cout << "当前工作目录: " << std::filesystem::current_path() << std::endl;

// 检查文件是否存在
#include <fstream>
std::ifstream testFile("Models/cube.obj");
if (testFile.good())
    std::cout << "文件存在" << std::endl;
else
    std::cout << "文件不存在！" << std::endl;
```

---

## 阶段3：渲染测试

### 3.1 在场景中渲染模型

修改渲染循环，添加模型渲染代码：

```cpp
// ========================================
// 渲染循环（在main函数中）
// ========================================
while (!window.ShouldClose())
{
    // ... 处理输入、deltaTime等 ...

    // 清屏
    glClearColor(0.1f, 0.1f, 0.15f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // ========================================
    // 1. 渲染地形（如果有）
    // ========================================
    terrainShader.Use();
    terrainShader.SetMat4("view", camera.GetViewMatrix());
    terrainShader.SetMat4("projection", projection);

    glm::mat4 terrainModel = glm::mat4(1.0f);
    terrainShader.SetMat4("model", terrainModel);
    terrain.Render();

    // ========================================
    // 2. 【新增】渲染测试模型
    // ========================================
    // 使用相同的着色器（地形着色器也可以用于模型）
    terrainShader.Use();

    // 设置模型矩阵：放置在相机前方
    glm::mat4 modelMatrix = glm::mat4(1.0f);
    modelMatrix = glm::translate(modelMatrix, glm::vec3(0.0f, 5.0f, -20.0f));  // 前方20米，高5米
    modelMatrix = glm::scale(modelMatrix, glm::vec3(3.0f));  // 放大3倍

    terrainShader.SetMat4("model", modelMatrix);
    testModel.Render();

    // ... 交换缓冲区等 ...
    window.SwapBuffers();
    window.PollEvents();
}
```

### 3.2 运行并查看效果

按 **F5** 运行

**预期效果：**
- 你应该能在场景中看到一个立方体
- 立方体位于相机前方
- 有光照效果（如果着色器支持）

### 3.3 调试：如果看不到模型

**可能原因1：模型太小**
```cpp
// 尝试放大模型
modelMatrix = glm::scale(modelMatrix, glm::vec3(10.0f));  // 放大10倍
```

**可能原因2：模型在相机后面**
```cpp
// 确保模型在相机前方
modelMatrix = glm::translate(modelMatrix, glm::vec3(0.0f, 2.0f, -10.0f));
```

**可能原因3：深度测试未启用**
```cpp
// 在初始化代码中确保启用深度测试
glEnable(GL_DEPTH_TEST);
```

**可能原因4：背面剔除导致看不见**
```cpp
// 临时禁用背面剔除
glDisable(GL_CULL_FACE);
```

**可能原因5：模型是黑色的**
```cpp
// 提高环境光强度
terrainShader.SetFloat("ambientStrength", 0.5f);  // 默认可能是0.1
```

---

## 🎯 完整测试代码示例

这是一个完整的main.cpp片段，展示如何集成模型加载：

```cpp
#include "Model.h"  // 【新增】包含Model类

int main()
{
    // ========================================
    // 初始化
    // ========================================
    Window window(1920, 1080, "CSC8502 Coursework");
    if (!window.IsValid())
        return -1;

    // 启用深度测试
    glEnable(GL_DEPTH_TEST);

    // 加载着色器
    Shader terrainShader("Shaders/terrainVertex.glsl", "Shaders/terrainFragment.glsl");

    // 创建相机
    Camera camera(glm::vec3(0.0f, 10.0f, 30.0f));

    // 加载地形
    Terrain terrain("Textures/heightmap.png", 150.0f, 5.0f);

    // ========================================
    // 【新增】加载测试模型
    // ========================================
    std::cout << "\n=== 测试模型加载 ===" << std::endl;
    Model cubeModel("Models/cube.obj");

    if (!cubeModel.IsLoaded())
    {
        std::cerr << "警告：模型加载失败，但程序继续运行" << std::endl;
    }

    // 投影矩阵
    glm::mat4 projection = glm::perspective(
        glm::radians(45.0f),
        1920.0f / 1080.0f,
        0.1f,
        1000.0f
    );

    // ========================================
    // 渲染循环
    // ========================================
    float deltaTime = 0.0f;
    float lastFrame = 0.0f;

    while (!window.ShouldClose())
    {
        // 计算deltaTime
        float currentFrame = static_cast<float>(glfwGetTime());
        deltaTime = currentFrame - lastFrame;
        lastFrame = currentFrame;

        // 处理输入
        camera.ProcessKeyboard(window.GetGLFWWindow(), deltaTime);

        // 清屏
        glClearColor(0.1f, 0.1f, 0.15f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        // ========================================
        // 设置着色器uniform（所有物体共用）
        // ========================================
        terrainShader.Use();
        terrainShader.SetMat4("view", camera.GetViewMatrix());
        terrainShader.SetMat4("projection", projection);
        terrainShader.SetVec3("viewPos", camera.GetPosition());
        terrainShader.SetVec3("lightPos", glm::vec3(100.0f, 100.0f, 100.0f));

        // ========================================
        // 渲染地形
        // ========================================
        glm::mat4 terrainModel = glm::mat4(1.0f);
        terrainShader.SetMat4("model", terrainModel);
        terrain.Render();

        // ========================================
        // 【新增】渲染立方体模型
        // ========================================
        if (cubeModel.IsLoaded())
        {
            glm::mat4 cubeModelMatrix = glm::mat4(1.0f);
            cubeModelMatrix = glm::translate(cubeModelMatrix, glm::vec3(0.0f, 10.0f, -30.0f));
            cubeModelMatrix = glm::rotate(cubeModelMatrix, currentFrame, glm::vec3(0, 1, 0));  // 旋转
            cubeModelMatrix = glm::scale(cubeModelMatrix, glm::vec3(5.0f));

            terrainShader.SetMat4("model", cubeModelMatrix);
            cubeModel.Render();
        }

        // 交换缓冲区
        window.SwapBuffers();
        window.PollEvents();
    }

    return 0;
}
```

---

## ✅ 测试成功标准

完成以上3个阶段后，你应该：

- [x] **编译成功** - 无错误，无警告
- [x] **加载成功** - 控制台输出 "✓ 模型加载成功！"
- [x] **渲染成功** - 在场景中能看到立方体（或其他模型）

---

## 🚀 下一步

测试成功后，你可以：

1. **加载真实的树木/岩石模型**
   - 替换 "Models/cube.obj" 为你下载的模型路径
   - 调整位置、缩放

2. **批量放置多个模型**
   - 使用循环放置多棵树
   - 参考"OBJ模型加载完整实现指南.md"中的批量放置代码

3. **在地形上放置模型**
   - 使用 `terrain.GetHeightAt(x, z)` 获取地形高度
   - 让树木放置在正确的高度上

---

## 🐛 常见问题

### Q1: 编译错误 "cannot open include file 'tiny_obj_loader.h'"

**解决：**
- 检查 `Dependencies\TinyOBJ\tiny_obj_loader.h` 是否存在
- 检查项目属性 → C/C++ → 附加包含目录是否包含：
  ```
  $(ProjectDir)Dependencies\TinyOBJ
  ```

### Q2: 加载失败 "Failed to open file"

**解决：**
- 检查工作目录是否正确（应该是项目根目录）
- 右键项目 → 属性 → 调试 → 工作目录 设置为 `$(ProjectDir)..`
- 或者使用绝对路径测试：`Model("D:\\...\\Models\\cube.obj")`

### Q3: 模型显示为黑色

**解决：**
```cpp
// 提高环境光
terrainShader.SetFloat("ambientStrength", 0.5f);

// 或者临时使用纯白色材质（在fragment shader中）
```

### Q4: 看不到模型

**解决：**
```cpp
// 1. 放大模型
modelMatrix = glm::scale(modelMatrix, glm::vec3(10.0f));

// 2. 禁用背面剔除
glDisable(GL_CULL_FACE);

// 3. 确保模型在相机前方
modelMatrix = glm::translate(modelMatrix, glm::vec3(0, 5, -20));
```

---

好运！如果遇到任何问题，随时查看控制台输出，它会告诉你问题在哪里。 😊
