# 修改水面位置的两种方案

## 当前实现分析

### 位置控制代码位置：
**`WaterPlane.cpp:80-98`**

```cpp
// 第80-82行：控制水面中心位置
float startX = -m_Size / 2.0f;  // ← 让水面中心在X=0
float startZ = -m_Size / 2.0f;  // ← 让水面中心在Z=0

// 第96-98行：计算每个顶点位置
float posX = startX + x * cellSize;  // X坐标
float posY = m_WaterLevel;           // Y坐标（由构造函数参数控制）
float posZ = startZ + z * cellSize;  // Z坐标
```

### 当前位置计算结果

对于 `WaterPlane water(2.0f, 50.0f, 100);`：
- **水面高度（Y）**：2.0
- **水面大小**：50×50
- **水面中心**：**(0, 2.0, 0)** ← 固定在原点上方
- **X范围**：-25.0 到 +25.0
- **Z范围**：-25.0 到 +25.0

---

## ✅ 方法1：修改WaterPlane类（最佳方案）

**优点：**
- ✅ 直接在顶点生成时设置位置，性能最优
- ✅ 代码清晰，参数直观
- ✅ 适合固定位置的水面

### 实现步骤

#### 1️⃣ 修改 `WaterPlane.h` - 添加中心坐标参数

在构造函数中添加centerX和centerZ参数：

```cpp
// 原来的构造函数（第36行）：
WaterPlane(float waterLevel, float size, int resolution);

// 修改为：
WaterPlane(float waterLevel, float size, int resolution,
           float centerX = 0.0f, float centerZ = 0.0f);
//         ↑ 添加两个参数，默认值为0（保持向后兼容）
```

#### 2️⃣ 修改 `WaterPlane.h` - 添加成员变量

在private部分（约第67-71行）添加成员变量：

```cpp
private:
    // OpenGL对象
    unsigned int m_VAO;
    unsigned int m_VBO;
    unsigned int m_EBO;

    // 水面参数
    float m_WaterLevel;
    float m_Size;
    int m_Resolution;
    unsigned int m_IndexCount;

    // 新增：水面中心坐标
    float m_CenterX;  // ← 添加这行
    float m_CenterZ;  // ← 添加这行
```

#### 3️⃣ 修改 `WaterPlane.cpp` - 构造函数

在构造函数中接收并保存参数（第8-16行）：

```cpp
// 原来的构造函数：
WaterPlane::WaterPlane(float waterLevel, float size, int resolution)
    : m_VAO(0)
    , m_VBO(0)
    , m_EBO(0)
    , m_WaterLevel(waterLevel)
    , m_Size(size)
    , m_Resolution(resolution)
    , m_IndexCount(0)

// 修改为：
WaterPlane::WaterPlane(float waterLevel, float size, int resolution,
                       float centerX, float centerZ)
    : m_VAO(0)
    , m_VBO(0)
    , m_EBO(0)
    , m_WaterLevel(waterLevel)
    , m_Size(size)
    , m_Resolution(resolution)
    , m_IndexCount(0)
    , m_CenterX(centerX)     // ← 添加
    , m_CenterZ(centerZ)     // ← 添加
```

#### 4️⃣ 修改 `WaterPlane.cpp` - GenerateMesh函数

修改起始位置计算（第80-82行）：

```cpp
// 原来的代码：
float startX = -m_Size / 2.0f;
float startZ = -m_Size / 2.0f;

// 修改为：
float startX = m_CenterX - m_Size / 2.0f;  // ← 相对于中心点偏移
float startZ = m_CenterZ - m_Size / 2.0f;  // ← 相对于中心点偏移
```

#### 5️⃣ 在main.cpp中使用新参数

```cpp
// 原来的调用：
WaterPlane water(2.0f, 50.0f, 100);

// 新的调用方式：
// 1. 使用默认中心位置（0, 0）- 向后兼容
WaterPlane water(2.0f, 50.0f, 100);

// 2. 指定水面中心位置
WaterPlane water(2.0f, 50.0f, 100, 50.0f, 50.0f);
//                                  ↑      ↑
//                                centerX centerZ
//               水面中心将在世界坐标 (50, 2.0, 50)

// 3. 示例：如果地形是100×100，中心在(50, ?, 50)
//    让水面也在地形中心：
WaterPlane water(2.0f, 40.0f, 100, 50.0f, 50.0f);
```

---

## ✅ 方法2：使用Model矩阵平移（更灵活）

**优点：**
- ✅ 不需要修改WaterPlane类
- ✅ 可以运行时动态移动水面
- ✅ 可以结合旋转、缩放等变换

**缺点：**
- ❌ 需要在着色器中进行矩阵运算（性能略差，但影响可忽略）

### 实现步骤

#### 在main.cpp的渲染循环中修改model矩阵

找到水面渲染代码（约350-400行），修改：

```cpp
// 原来的代码：
waterShader.Use();
waterShader.SetMat4("model", glm::mat4(1.0f));  // ← 单位矩阵，无变换
water.Render();

// 修改为：
waterShader.Use();

// 创建平移矩阵，将水面移动到 (50, 0, 50)
glm::mat4 waterModel = glm::mat4(1.0f);
waterModel = glm::translate(waterModel, glm::vec3(50.0f, 0.0f, 50.0f));
//                                                  ↑      ↑     ↑
//                                               X偏移  Y偏移  Z偏移
// 注意：Y偏移通常设为0，因为水面高度已经由构造函数参数控制

waterShader.SetMat4("model", waterModel);
water.Render();
```

### 动态移动水面示例

```cpp
// 让水面随时间移动（动态效果）
float time = glfwGetTime();
float offsetX = sin(time) * 10.0f;  // X方向来回摆动
float offsetZ = cos(time) * 10.0f;  // Z方向来回摆动

glm::mat4 waterModel = glm::mat4(1.0f);
waterModel = glm::translate(waterModel, glm::vec3(50.0f + offsetX, 0.0f, 50.0f + offsetZ));
waterShader.SetMat4("model", waterModel);
water.Render();
```

---

## 🎯 两种方法对比

| 特性 | 方法1：修改类 | 方法2：Model矩阵 |
|------|--------------|-----------------|
| **性能** | ⭐⭐⭐⭐⭐（最优） | ⭐⭐⭐⭐（略慢） |
| **实现难度** | 中等（需修改类） | 简单（只改main.cpp） |
| **代码清晰度** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| **灵活性** | 固定位置 | 可动态移动 |
| **推荐场景** | 固定位置的水面 | 需要移动的水面 |

---

## 🔧 实战示例

### 场景：地形是100×100，中心在(50, ?, 50)，想在地形中心放一个水坑

#### 方案A：使用方法1（推荐）

```cpp
// 1. 修改WaterPlane类（按照上面的步骤）

// 2. 在main.cpp中：
Terrain terrain("Textures/heightmap.png", 100.0f, 10.0f);

// 水面参数：
//   高度：2.0（坑底略上方）
//   大小：40×40（小于坑的直径）
//   分辨率：100
//   中心X：50.0（地形中心）
//   中心Z：50.0（地形中心）
WaterPlane water(2.0f, 40.0f, 100, 50.0f, 50.0f);
```

#### 方案B：使用方法2（无需修改类）

```cpp
// 1. 在main.cpp中：
Terrain terrain("Textures/heightmap.png", 100.0f, 10.0f);

// 水面默认中心在(0, 2.0, 0)
WaterPlane water(2.0f, 40.0f, 100);

// 2. 在渲染循环中：
waterShader.Use();
waterShader.SetFloat("time", glfwGetTime());
waterShader.SetVec3("viewPos", camera.Position);

// 使用model矩阵将水面平移到地形中心
glm::mat4 waterModel = glm::mat4(1.0f);
waterModel = glm::translate(waterModel, glm::vec3(50.0f, 0.0f, 50.0f));
waterShader.SetMat4("model", waterModel);
waterShader.SetMat4("view", camera.GetViewMatrix());
waterShader.SetMat4("projection", projection);

// 绑定天空盒纹理
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_CUBE_MAP, skyboxCubemapTexture);
waterShader.SetInt("skybox", 0);

water.Render();
```

---

## 📊 地形和水面坐标关系

### Terrain的坐标系统

查看 `Terrain.cpp:172-173`：
```cpp
float cellSizeX = m_TerrainSize / (m_Width - 1);
float cellSizeZ = m_TerrainSize / (m_Height - 1);
```

和 `Terrain.cpp:189-198`：
```cpp
float posX = x * cellSizeX;  // X坐标从0开始
// ...
float posZ = z * cellSizeZ;  // Z坐标从0开始
```

**地形坐标范围**（假设terrainSize=100）：
- X: **0 到 100**
- Z: **0 到 100**
- 地形中心: **(50, ?, 50)**

**水面默认坐标范围**（size=50）：
- X: **-25 到 +25**
- Z: **-25 到 +25**
- 水面中心: **(0, ?, 0)**

**问题：** 水面和地形中心不对齐！

**解决方案：** 将水面移动到 (50, Y, 50)，使用上述任一方法。

---

## ✅ 快速解决方案（推荐方法2）

如果你只是想快速看到效果，**不想修改WaterPlane类**，只需在main.cpp中找到水面渲染代码，添加一行：

```cpp
// 渲染水面
waterShader.Use();
// ... 设置其他uniform ...

// ⭐ 添加这行：将水面平移到地形中心
glm::mat4 waterModel = glm::translate(glm::mat4(1.0f), glm::vec3(50.0f, 0.0f, 50.0f));
waterShader.SetMat4("model", waterModel);

water.Render();
```

**就这么简单！水面现在会出现在地形中心 (50, 2.0, 50) 位置。**

---

## 🐛 调试技巧

### 如何确认水面位置

在main.cpp中添加调试输出：

```cpp
std::cout << "地形中心: (" << 100.0f / 2.0f << ", ?, " << 100.0f / 2.0f << ")" << std::endl;
std::cout << "水面中心: (50.0, " << water.GetWaterLevel() << ", 50.0)" << std::endl;
```

### 可视化辅助

在水面中心位置渲染一个小球体或立方体，确认位置正确。

---

## 📚 总结

**控制水面位置的关键代码位置：**
- **`WaterPlane.cpp:80-82`** - 计算startX和startZ
- **`WaterPlane.cpp:96-98`** - 设置每个顶点的位置

**推荐方案：**
- 🏆 **临时测试**：使用方法2（Model矩阵平移）
- 🏆 **正式项目**：使用方法1（修改WaterPlane类）

**下一步：**
1. 决定使用哪种方法
2. 按照上面的步骤实现
3. 编译运行，调整参数
4. 享受水面在地形坑中的完美反射效果！🌊
